---
description: 
globs: 
alwaysApply: true
---

# Guide: Adding Existing Userscripts to HQ-Userscripts

This guide outlines the process for integrating existing userscripts into the `HQ-Userscripts` repository using the Rollup build system and the established modular structure.

G:\Modding\_Github\HQ-Userscripts\

## Key Principles

1.  **Modularity:** Break down scripts into smaller, reusable functions or modules.
2.  **Reusability:** Leverage existing helper functions and UI components whenever possible.
3.  **Consistency:** Follow the established folder structure and coding style.
4.  **ES Modules:** Use `import` and `export` syntax exclusively.

## Folder Structure

Place new modules within the appropriate `src` subdirectories:

*   `src/`
    *   `data/`: Static data, configurations (like `MANIFEST.js`).
    *   `helpers/`:
        *   `Core/`: General-purpose helper functions (utilities, formatting, UI interactions).
        *   `[ScriptName]/`: Helpers specific to a particular script or feature set.
    *   `initialization/`: Code related to the initial setup and execution (`init.js`, `addMenuButton.js`).
    *   `main.js`: The main entry point for Rollup.
    *   `meta.js`: Userscript metadata header.
    *   `ui/`:
        *   `components/`: Reusable UI elements (script cards, lists, etc.).
        *   `modals/`: Code for modal dialogs (main manager modal, settings modals).
            *   `core/`: Core modal logic (`showModal`, `hideModal`, `loadTabContent`).
            *   `helpers/`: Helpers specifically for modals.
            *   `settings/`: Settings-related modal components.
            *   `tabs/`: Content rendering logic for different tabs within modals.
        *   `[ScriptName]/`: UI components specific to a particular script.

**IMPORTANT:**

*   **Do not** create large, monolithic script files.
*   Break down functionality logically.
*   Place files in the most specific relevant directory.

## Steps for Integration

1.  **Analyze the Script:**
    *   Identify the core functionality.
    *   Break it down into logical parts (e.g., data fetching, UI manipulation, event handling, utility functions).

2.  **Check for Existing Modules:**
    *   Before writing new code, thoroughly check the `src/helpers` and `src/ui` directories.
    *   **Is there an existing function that does what you need?** Use it!
    *   **Can an existing function be slightly modified or generalized?** Consider refactoring the existing function instead of creating a duplicate.

3.  **Create New Modules:**
    *   For each logical part identified in step 1, create a new `.js` file.
    *   Place the file in the appropriate directory based on the structure outlined above.
    *   Write the code using modern JavaScript (ES6+).
    *   **Use `export`** to make functions, classes, or constants available to other modules.
        ```javascript
        // Example: src/helpers/MyFeature/calculateValue.js
        export function calculateValue(input) {
          // ... calculation logic ...
          return result;
        }
        ```

4.  **Import Dependencies:**
    *   In each new module, **use `import`** to bring in functions or data from other modules.
    *   Use **relative paths** for imports.
        ```javascript
        // Example: src/ui/MyFeature/displayComponent.js
        import { calculateValue } from '../../helpers/MyFeature/calculateValue.js';
        import { MANIFEST } from '../../data/MANIFEST.js';

        export function displayComponent(container) {
          const value = calculateValue(MANIFEST.someData);
          // ... UI logic ...
        }
        ```

5.  **Update Entry Point / Initialization (If Necessary):**
    *   If the new script needs to run automatically, integrate its initialization logic into `src/initialization/init.js` or a related file.
    *   Ensure the necessary functions are imported into `init.js`.

6.  **Update Script Manifest (`src/data/MANIFEST.js`):**
    *   Add a new entry to the `scripts` array for the newly integrated script.
    *   Include details like `id`, `name`, `version`, `description`, `category`, `executionPhase`, `settings` (if any), etc.
    *   This manifest is used by the manager UI to display information about available scripts.

7.  **Update Metadata (`src/meta.js`) (If Necessary):**
    *   Add any new `@grant` permissions required by the script.
    *   Adjust `@match` patterns if needed.

8.  **Test:**
    *   Run the Rollup build (`npm run build` or `yarn build`).
    *   Install the generated userscript (`rpghq-userscript-manager.user.js`) in your browser/userscript manager.
    *   Thoroughly test the new functionality on the target website(s).

## Example: Adding a "Quick Reply" Feature

1.  **Analyze:** Feature needs to add a button to posts, open a small editor, and submit a reply.
2.  **Check Existing:** Look for helpers related to DOM manipulation, event listeners, UI creation.
3.  **Create Modules:**
    *   `src/helpers/QuickReply/addReplyButton.js` (Adds button to posts)
    *   `src/ui/QuickReply/createEditor.js` (Creates the editor UI)
    *   `src/helpers/QuickReply/submitReply.js` (Handles form submission)
4.  **Import/Export:** Add `export` to each function. `addReplyButton.js` might import `createEditor.js`.
5.  **Initialize:** Modify `src/initialization/init.js` (or a function it calls) to execute `addReplyButton` when appropriate (e.g., after posts are loaded).
6.  **Manifest:** Add an entry for the new script in `src/data/MANIFEST.js`.
7.  **Metadata:** Add any necessary `@grant` permissions to `src/meta.js`.

By following these steps and prioritizing modularity and reuse, we can maintain a clean, manageable, and efficient codebase.
